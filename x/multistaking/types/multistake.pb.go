// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: restaking_protocol/multistake/v1/multistake.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MultiStakingDenomWhiteList struct {
	DenomList []string `protobuf:"bytes,1,rep,name=denom_list,json=denomList,proto3" json:"denom_list,omitempty"`
}

func (m *MultiStakingDenomWhiteList) Reset()         { *m = MultiStakingDenomWhiteList{} }
func (m *MultiStakingDenomWhiteList) String() string { return proto.CompactTextString(m) }
func (*MultiStakingDenomWhiteList) ProtoMessage()    {}
func (*MultiStakingDenomWhiteList) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{0}
}
func (m *MultiStakingDenomWhiteList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingDenomWhiteList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingDenomWhiteList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingDenomWhiteList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingDenomWhiteList.Merge(m, src)
}
func (m *MultiStakingDenomWhiteList) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingDenomWhiteList) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingDenomWhiteList.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingDenomWhiteList proto.InternalMessageInfo

func (m *MultiStakingDenomWhiteList) GetDenomList() []string {
	if m != nil {
		return m.DenomList
	}
	return nil
}

type EquivalentMultiplierRecord struct {
	EpochNumber int64  `protobuf:"varint,1,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
	Denom       string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Multiplier  Dec    `protobuf:"bytes,3,opt,name=multiplier,proto3,customtype=Dec" json:"multiplier"`
}

func (m *EquivalentMultiplierRecord) Reset()         { *m = EquivalentMultiplierRecord{} }
func (m *EquivalentMultiplierRecord) String() string { return proto.CompactTextString(m) }
func (*EquivalentMultiplierRecord) ProtoMessage()    {}
func (*EquivalentMultiplierRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{1}
}
func (m *EquivalentMultiplierRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquivalentMultiplierRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquivalentMultiplierRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquivalentMultiplierRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquivalentMultiplierRecord.Merge(m, src)
}
func (m *EquivalentMultiplierRecord) XXX_Size() int {
	return m.Size()
}
func (m *EquivalentMultiplierRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_EquivalentMultiplierRecord.DiscardUnknown(m)
}

var xxx_messageInfo_EquivalentMultiplierRecord proto.InternalMessageInfo

func (m *EquivalentMultiplierRecord) GetEpochNumber() int64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *EquivalentMultiplierRecord) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MultiStakingDelegation struct {
	DelegatorAddress       string      `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
	ValidatorAddress       string      `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	DelegationAmount       types.Coin  `protobuf:"bytes,3,opt,name=delegation_amount,json=delegationAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"delegation_amount"`
	EquivalentStakedAmount *types.Coin `protobuf:"bytes,4,opt,name=equivalent_staked_amount,json=equivalentStakedAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"equivalent_staked_amount,omitempty"`
}

func (m *MultiStakingDelegation) Reset()         { *m = MultiStakingDelegation{} }
func (m *MultiStakingDelegation) String() string { return proto.CompactTextString(m) }
func (*MultiStakingDelegation) ProtoMessage()    {}
func (*MultiStakingDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{2}
}
func (m *MultiStakingDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingDelegation.Merge(m, src)
}
func (m *MultiStakingDelegation) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingDelegation proto.InternalMessageInfo

func (m *MultiStakingDelegation) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *MultiStakingDelegation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MultiStakingDelegation) GetDelegationAmount() types.Coin {
	if m != nil {
		return m.DelegationAmount
	}
	return types.Coin{}
}

func (m *MultiStakingDelegation) GetEquivalentStakedAmount() *types.Coin {
	if m != nil {
		return m.EquivalentStakedAmount
	}
	return nil
}

type MultiStakingAgent struct {
	Id               uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StakeDenom       string `protobuf:"bytes,2,opt,name=stake_denom,json=stakeDenom,proto3" json:"stake_denom,omitempty"`
	DelegateAddress  string `protobuf:"bytes,3,opt,name=delegate_address,json=delegateAddress,proto3" json:"delegate_address,omitempty"`
	ValidatorAddress string `protobuf:"bytes,4,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	WithdrawAddress  string `protobuf:"bytes,5,opt,name=withdraw_address,json=withdrawAddress,proto3" json:"withdraw_address,omitempty"`
	StakedAmount     Int    `protobuf:"bytes,6,opt,name=staked_amount,json=stakedAmount,proto3,customtype=Int" json:"staked_amount"`
	Shares           Int    `protobuf:"bytes,7,opt,name=shares,proto3,customtype=Int" json:"shares"`
	RewardAmount     Int    `protobuf:"bytes,8,opt,name=reward_amount,json=rewardAmount,proto3,customtype=Int" json:"reward_amount"`
}

func (m *MultiStakingAgent) Reset()         { *m = MultiStakingAgent{} }
func (m *MultiStakingAgent) String() string { return proto.CompactTextString(m) }
func (*MultiStakingAgent) ProtoMessage()    {}
func (*MultiStakingAgent) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{3}
}
func (m *MultiStakingAgent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingAgent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingAgent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingAgent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingAgent.Merge(m, src)
}
func (m *MultiStakingAgent) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingAgent) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingAgent.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingAgent proto.InternalMessageInfo

func (m *MultiStakingAgent) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MultiStakingAgent) GetStakeDenom() string {
	if m != nil {
		return m.StakeDenom
	}
	return ""
}

func (m *MultiStakingAgent) GetDelegateAddress() string {
	if m != nil {
		return m.DelegateAddress
	}
	return ""
}

func (m *MultiStakingAgent) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MultiStakingAgent) GetWithdrawAddress() string {
	if m != nil {
		return m.WithdrawAddress
	}
	return ""
}

type MultiStakingUnbonding struct {
	AgentId          uint64                       `protobuf:"varint,1,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
	DelegatorAddress string                       `protobuf:"bytes,2,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
	Entries          []MultiStakingUnbondingEntry `protobuf:"bytes,3,rep,name=entries,proto3" json:"entries"`
}

func (m *MultiStakingUnbonding) Reset()         { *m = MultiStakingUnbonding{} }
func (m *MultiStakingUnbonding) String() string { return proto.CompactTextString(m) }
func (*MultiStakingUnbonding) ProtoMessage()    {}
func (*MultiStakingUnbonding) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{4}
}
func (m *MultiStakingUnbonding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingUnbonding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingUnbonding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingUnbonding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingUnbonding.Merge(m, src)
}
func (m *MultiStakingUnbonding) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingUnbonding) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingUnbonding.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingUnbonding proto.InternalMessageInfo

func (m *MultiStakingUnbonding) GetAgentId() uint64 {
	if m != nil {
		return m.AgentId
	}
	return 0
}

func (m *MultiStakingUnbonding) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *MultiStakingUnbonding) GetEntries() []MultiStakingUnbondingEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MultiStakingUnbondingEntry struct {
	CompletionTime time.Time  `protobuf:"bytes,1,opt,name=completion_time,json=completionTime,proto3,stdtime" json:"completion_time"`
	InitialBalance types.Coin `protobuf:"bytes,2,opt,name=initial_balance,json=initialBalance,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"initial_balance"`
	Balance        types.Coin `protobuf:"bytes,3,opt,name=balance,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coin" json:"balance"`
}

func (m *MultiStakingUnbondingEntry) Reset()         { *m = MultiStakingUnbondingEntry{} }
func (m *MultiStakingUnbondingEntry) String() string { return proto.CompactTextString(m) }
func (*MultiStakingUnbondingEntry) ProtoMessage()    {}
func (*MultiStakingUnbondingEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{5}
}
func (m *MultiStakingUnbondingEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStakingUnbondingEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStakingUnbondingEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStakingUnbondingEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStakingUnbondingEntry.Merge(m, src)
}
func (m *MultiStakingUnbondingEntry) XXX_Size() int {
	return m.Size()
}
func (m *MultiStakingUnbondingEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStakingUnbondingEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStakingUnbondingEntry proto.InternalMessageInfo

func (m *MultiStakingUnbondingEntry) GetCompletionTime() time.Time {
	if m != nil {
		return m.CompletionTime
	}
	return time.Time{}
}

func (m *MultiStakingUnbondingEntry) GetInitialBalance() types.Coin {
	if m != nil {
		return m.InitialBalance
	}
	return types.Coin{}
}

func (m *MultiStakingUnbondingEntry) GetBalance() types.Coin {
	if m != nil {
		return m.Balance
	}
	return types.Coin{}
}

type DAPair struct {
	DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
	AgentId          uint64 `protobuf:"varint,2,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
}

func (m *DAPair) Reset()         { *m = DAPair{} }
func (m *DAPair) String() string { return proto.CompactTextString(m) }
func (*DAPair) ProtoMessage()    {}
func (*DAPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{6}
}
func (m *DAPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DAPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DAPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DAPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DAPair.Merge(m, src)
}
func (m *DAPair) XXX_Size() int {
	return m.Size()
}
func (m *DAPair) XXX_DiscardUnknown() {
	xxx_messageInfo_DAPair.DiscardUnknown(m)
}

var xxx_messageInfo_DAPair proto.InternalMessageInfo

func (m *DAPair) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *DAPair) GetAgentId() uint64 {
	if m != nil {
		return m.AgentId
	}
	return 0
}

type DAPairs struct {
	Pairs []DAPair `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs"`
}

func (m *DAPairs) Reset()         { *m = DAPairs{} }
func (m *DAPairs) String() string { return proto.CompactTextString(m) }
func (*DAPairs) ProtoMessage()    {}
func (*DAPairs) Descriptor() ([]byte, []int) {
	return fileDescriptor_70bea4b7fbecdd39, []int{7}
}
func (m *DAPairs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DAPairs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DAPairs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DAPairs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DAPairs.Merge(m, src)
}
func (m *DAPairs) XXX_Size() int {
	return m.Size()
}
func (m *DAPairs) XXX_DiscardUnknown() {
	xxx_messageInfo_DAPairs.DiscardUnknown(m)
}

var xxx_messageInfo_DAPairs proto.InternalMessageInfo

func (m *DAPairs) GetPairs() []DAPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func init() {
	proto.RegisterType((*MultiStakingDenomWhiteList)(nil), "restaking_protocol.multistake.v1.MultiStakingDenomWhiteList")
	proto.RegisterType((*EquivalentMultiplierRecord)(nil), "restaking_protocol.multistake.v1.EquivalentMultiplierRecord")
	proto.RegisterType((*MultiStakingDelegation)(nil), "restaking_protocol.multistake.v1.MultiStakingDelegation")
	proto.RegisterType((*MultiStakingAgent)(nil), "restaking_protocol.multistake.v1.MultiStakingAgent")
	proto.RegisterType((*MultiStakingUnbonding)(nil), "restaking_protocol.multistake.v1.MultiStakingUnbonding")
	proto.RegisterType((*MultiStakingUnbondingEntry)(nil), "restaking_protocol.multistake.v1.MultiStakingUnbondingEntry")
	proto.RegisterType((*DAPair)(nil), "restaking_protocol.multistake.v1.DAPair")
	proto.RegisterType((*DAPairs)(nil), "restaking_protocol.multistake.v1.DAPairs")
}

func init() {
	proto.RegisterFile("restaking_protocol/multistake/v1/multistake.proto", fileDescriptor_70bea4b7fbecdd39)
}

var fileDescriptor_70bea4b7fbecdd39 = []byte{
	// 825 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6a, 0xeb, 0x46,
	0x14, 0xb6, 0x6c, 0xc7, 0x8e, 0xc7, 0xb7, 0x49, 0xee, 0x90, 0x06, 0xdb, 0x50, 0xdb, 0xf5, 0x26,
	0x86, 0x10, 0x09, 0xbb, 0xab, 0xd2, 0x52, 0xb0, 0xe3, 0x2c, 0x02, 0x4d, 0x5b, 0x94, 0x96, 0x42,
	0x29, 0x88, 0x91, 0x34, 0x95, 0xa7, 0x91, 0x66, 0x5c, 0x69, 0x6c, 0x37, 0xbb, 0x3e, 0x42, 0x9e,
	0xa3, 0xeb, 0x3c, 0x43, 0xc9, 0x32, 0x64, 0xd3, 0xd2, 0x45, 0x52, 0x92, 0x7d, 0x9f, 0xe1, 0x32,
	0x33, 0x92, 0x22, 0x63, 0x83, 0x08, 0x64, 0x25, 0x9d, 0xff, 0xef, 0x9c, 0xef, 0xe8, 0x08, 0x0c,
	0x42, 0x1c, 0x71, 0x74, 0x49, 0xa8, 0x67, 0xcd, 0x42, 0xc6, 0x99, 0xc3, 0x7c, 0x23, 0x98, 0xfb,
	0x9c, 0x08, 0x2d, 0x36, 0x16, 0x83, 0x8c, 0xa4, 0x4b, 0x0f, 0xd8, 0x5d, 0x0f, 0xd1, 0x33, 0x4e,
	0x8b, 0x41, 0xab, 0xe3, 0x31, 0xe6, 0xf9, 0xd8, 0x90, 0x66, 0x7b, 0xfe, 0x8b, 0xc1, 0x49, 0x20,
	0x62, 0x82, 0x99, 0x4a, 0xd1, 0xda, 0xf7, 0x98, 0xc7, 0xe4, 0xab, 0x21, 0xde, 0x62, 0x6d, 0xd3,
	0x61, 0x51, 0xc0, 0x22, 0x95, 0xd5, 0x50, 0x42, 0x6c, 0x6a, 0x2b, 0xc9, 0xb0, 0x51, 0x24, 0x40,
	0xd9, 0x98, 0xa3, 0x81, 0xe1, 0x30, 0x42, 0x95, 0xbd, 0xf7, 0x05, 0x68, 0x9d, 0x0b, 0x08, 0x17,
	0x0a, 0xd8, 0x04, 0x53, 0x16, 0xfc, 0x38, 0x25, 0x1c, 0x7f, 0x4d, 0x22, 0x0e, 0x3f, 0x01, 0xc0,
	0x15, 0x1a, 0xcb, 0x27, 0x11, 0x6f, 0x68, 0xdd, 0x52, 0xbf, 0x66, 0xd6, 0xa4, 0x46, 0x98, 0x7b,
	0xd7, 0x1a, 0x68, 0x9d, 0xfe, 0x36, 0x27, 0x0b, 0xe4, 0x63, 0xca, 0x65, 0x9e, 0x99, 0x4f, 0x70,
	0x68, 0x62, 0x87, 0x85, 0x2e, 0xfc, 0x14, 0xbc, 0xc3, 0x33, 0xe6, 0x4c, 0x2d, 0x3a, 0x0f, 0x6c,
	0x1c, 0x36, 0xb4, 0xae, 0xd6, 0x2f, 0x99, 0x75, 0xa9, 0xfb, 0x46, 0xaa, 0xe0, 0x3e, 0xd8, 0x92,
	0xe9, 0x1a, 0xc5, 0xae, 0xd6, 0xaf, 0x99, 0x4a, 0x80, 0x9f, 0x03, 0x10, 0xa4, 0xc9, 0x1a, 0x25,
	0x61, 0x1a, 0x37, 0x6f, 0x1f, 0x3a, 0x85, 0x7f, 0x1f, 0x3a, 0xa5, 0x09, 0x76, 0xee, 0x6f, 0x8e,
	0x41, 0xdc, 0xe5, 0x04, 0x3b, 0x66, 0xc6, 0xb9, 0xf7, 0x7f, 0x11, 0x1c, 0xac, 0x36, 0xe4, 0x63,
	0x0f, 0x71, 0xc2, 0x28, 0x3c, 0x02, 0xef, 0x5d, 0x25, 0xb1, 0xd0, 0x42, 0xae, 0x1b, 0xe2, 0x28,
	0x92, 0x98, 0x6a, 0xe6, 0x5e, 0x6a, 0x18, 0x29, 0xbd, 0x70, 0x5e, 0x20, 0x9f, 0xb8, 0x2b, 0xce,
	0x0a, 0xe4, 0x5e, 0x6a, 0x48, 0x9c, 0x97, 0x69, 0x66, 0xc2, 0xa8, 0x85, 0x02, 0x36, 0xa7, 0x5c,
	0xc2, 0xae, 0x0f, 0x9b, 0x7a, 0x0c, 0x54, 0x10, 0xa0, 0xc7, 0x04, 0xe8, 0x27, 0x8c, 0xd0, 0xb1,
	0x21, 0x3a, 0xfa, 0xf3, 0xb1, 0x73, 0xe8, 0x11, 0x3e, 0x9d, 0xdb, 0xba, 0xc3, 0x82, 0x98, 0xbb,
	0xf8, 0x71, 0x1c, 0xb9, 0x97, 0x06, 0xbf, 0x9a, 0xe1, 0x48, 0x06, 0xa4, 0x28, 0x09, 0xa3, 0x23,
	0x59, 0x03, 0xfe, 0xa1, 0x81, 0x06, 0x4e, 0x09, 0xb0, 0xe4, 0x1e, 0xb9, 0x09, 0x80, 0x72, 0x1e,
	0x80, 0xa3, 0xd7, 0x14, 0x3f, 0x78, 0xa9, 0x73, 0x21, 0xcb, 0x28, 0x08, 0xbd, 0xdb, 0x12, 0x78,
	0x9f, 0x1d, 0xf8, 0xc8, 0xc3, 0x94, 0xc3, 0x1d, 0x50, 0x24, 0xae, 0x1c, 0x6e, 0xd9, 0x2c, 0x12,
	0x17, 0x76, 0x40, 0x5d, 0x82, 0xb3, 0xb2, 0x6c, 0x03, 0xa9, 0x92, 0x2b, 0x07, 0x4f, 0x40, 0xd2,
	0x1d, 0x4e, 0xc7, 0xad, 0x88, 0x6f, 0xdc, 0xdf, 0x1c, 0xef, 0xc7, 0x3d, 0xc4, 0x03, 0xbf, 0xe0,
	0x21, 0xa1, 0x9e, 0xb9, 0x9b, 0x44, 0x24, 0x3c, 0x9c, 0x6e, 0x22, 0xad, 0x9c, 0x93, 0x65, 0x9d,
	0xce, 0x13, 0xb0, 0xb7, 0x24, 0x7c, 0xea, 0x86, 0x68, 0x99, 0x66, 0xd9, 0xca, 0xc3, 0x92, 0x44,
	0x24, 0x49, 0xbe, 0x02, 0x1f, 0xad, 0xd2, 0x51, 0x59, 0x5d, 0xe3, 0x33, 0xca, 0x33, 0x6b, 0x7c,
	0x46, 0xb9, 0xf9, 0x2e, 0xca, 0xcc, 0x15, 0x0e, 0x40, 0x25, 0x9a, 0xa2, 0x10, 0x47, 0x8d, 0x6a,
	0x5e, 0x60, 0xec, 0x28, 0x4a, 0x86, 0x78, 0x89, 0xc2, 0xb4, 0xe4, 0x76, 0x6e, 0x49, 0xe5, 0x1f,
	0x53, 0xf9, 0xb7, 0x06, 0x3e, 0xce, 0x52, 0xf9, 0x03, 0xb5, 0x19, 0x75, 0x09, 0xf5, 0x60, 0x13,
	0x6c, 0x23, 0xc1, 0xab, 0x95, 0x92, 0x5a, 0x95, 0xf2, 0x99, 0x2b, 0x66, 0xbe, 0xfe, 0x55, 0x15,
	0xf3, 0x66, 0xbe, 0xf6, 0xbd, 0xfd, 0x0c, 0xaa, 0x98, 0xf2, 0x90, 0x60, 0x41, 0x7b, 0xa9, 0x5f,
	0x1f, 0x7e, 0xa9, 0xe7, 0x5d, 0x4b, 0x7d, 0x23, 0xd6, 0x53, 0xca, 0xc3, 0xab, 0x71, 0x59, 0xf4,
	0x6c, 0x26, 0x29, 0x7b, 0x7f, 0x15, 0x57, 0xcf, 0xdc, 0xaa, 0x37, 0x3c, 0x07, 0xbb, 0x0e, 0x0b,
	0x66, 0x3e, 0x96, 0xdf, 0xaf, 0xb8, 0xb9, 0xb2, 0xcb, 0xfa, 0xb0, 0xa5, 0xab, 0x83, 0xac, 0x27,
	0x07, 0x59, 0xff, 0x3e, 0x39, 0xc8, 0xe3, 0x6d, 0x51, 0xe2, 0xfa, 0xb1, 0xa3, 0x99, 0x3b, 0x2f,
	0xc1, 0xc2, 0x0c, 0x23, 0xb0, 0x4b, 0x28, 0xe1, 0x04, 0xf9, 0x96, 0x8d, 0x7c, 0x44, 0x1d, 0x2c,
	0x07, 0xf2, 0xb6, 0xc7, 0x60, 0x27, 0x2e, 0x31, 0x56, 0x15, 0xa0, 0x0b, 0xaa, 0x49, 0xb1, 0xb7,
	0xbf, 0x3c, 0x49, 0xea, 0xde, 0xaf, 0xa0, 0x32, 0x19, 0x7d, 0x87, 0x48, 0xb8, 0x99, 0x77, 0xed,
	0xd5, 0xbc, 0x67, 0x37, 0xab, 0xb8, 0xb2, 0x59, 0xbd, 0x6f, 0x41, 0x55, 0xd5, 0x8a, 0xe0, 0x04,
	0x6c, 0xcd, 0xc4, 0x8b, 0xfc, 0x05, 0xd5, 0x87, 0xfd, 0xfc, 0xdd, 0x50, 0x91, 0xf1, 0x1e, 0xa8,
	0xe0, 0xf1, 0xe8, 0xf6, 0xa9, 0xad, 0xdd, 0x3d, 0xb5, 0xb5, 0xff, 0x9e, 0xda, 0xda, 0xf5, 0x73,
	0xbb, 0x70, 0xf7, 0xdc, 0x2e, 0xfc, 0xf3, 0xdc, 0x2e, 0xfc, 0x74, 0xb8, 0xe1, 0x67, 0xfe, 0xfb,
	0xcb, 0x0f, 0x9c, 0x50, 0x4f, 0x4d, 0xc3, 0xae, 0x48, 0xf3, 0x67, 0x1f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x4a, 0xc0, 0x24, 0xe4, 0xfe, 0x07, 0x00, 0x00,
}

func (m *MultiStakingDenomWhiteList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingDenomWhiteList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingDenomWhiteList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DenomList) > 0 {
		for iNdEx := len(m.DenomList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DenomList[iNdEx])
			copy(dAtA[i:], m.DenomList[iNdEx])
			i = encodeVarintMultistake(dAtA, i, uint64(len(m.DenomList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EquivalentMultiplierRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquivalentMultiplierRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EquivalentMultiplierRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Multiplier.Size()
		i -= size
		if _, err := m.Multiplier.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.EpochNumber != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EquivalentStakedAmount != nil {
		{
			size, err := m.EquivalentStakedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMultistake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.DelegationAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingAgent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingAgent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingAgent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RewardAmount.Size()
		i -= size
		if _, err := m.RewardAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.StakedAmount.Size()
		i -= size
		if _, err := m.StakedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.WithdrawAddress) > 0 {
		i -= len(m.WithdrawAddress)
		copy(dAtA[i:], m.WithdrawAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.WithdrawAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DelegateAddress) > 0 {
		i -= len(m.DelegateAddress)
		copy(dAtA[i:], m.DelegateAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.DelegateAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StakeDenom) > 0 {
		i -= len(m.StakeDenom)
		copy(dAtA[i:], m.StakeDenom)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.StakeDenom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingUnbonding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingUnbonding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingUnbonding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMultistake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.AgentId != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.AgentId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiStakingUnbondingEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStakingUnbondingEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStakingUnbondingEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.InitialBalance.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMultistake(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CompletionTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CompletionTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintMultistake(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DAPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DAPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DAPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AgentId != 0 {
		i = encodeVarintMultistake(dAtA, i, uint64(m.AgentId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintMultistake(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DAPairs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DAPairs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DAPairs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pairs) > 0 {
		for iNdEx := len(m.Pairs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMultistake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintMultistake(dAtA []byte, offset int, v uint64) int {
	offset -= sovMultistake(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MultiStakingDenomWhiteList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DenomList) > 0 {
		for _, s := range m.DenomList {
			l = len(s)
			n += 1 + l + sovMultistake(uint64(l))
		}
	}
	return n
}

func (m *EquivalentMultiplierRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNumber != 0 {
		n += 1 + sovMultistake(uint64(m.EpochNumber))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = m.Multiplier.Size()
	n += 1 + l + sovMultistake(uint64(l))
	return n
}

func (m *MultiStakingDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = m.DelegationAmount.Size()
	n += 1 + l + sovMultistake(uint64(l))
	if m.EquivalentStakedAmount != nil {
		l = m.EquivalentStakedAmount.Size()
		n += 1 + l + sovMultistake(uint64(l))
	}
	return n
}

func (m *MultiStakingAgent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMultistake(uint64(m.Id))
	}
	l = len(m.StakeDenom)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = len(m.DelegateAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = len(m.WithdrawAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	l = m.StakedAmount.Size()
	n += 1 + l + sovMultistake(uint64(l))
	l = m.Shares.Size()
	n += 1 + l + sovMultistake(uint64(l))
	l = m.RewardAmount.Size()
	n += 1 + l + sovMultistake(uint64(l))
	return n
}

func (m *MultiStakingUnbonding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentId != 0 {
		n += 1 + sovMultistake(uint64(m.AgentId))
	}
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovMultistake(uint64(l))
		}
	}
	return n
}

func (m *MultiStakingUnbondingEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CompletionTime)
	n += 1 + l + sovMultistake(uint64(l))
	l = m.InitialBalance.Size()
	n += 1 + l + sovMultistake(uint64(l))
	l = m.Balance.Size()
	n += 1 + l + sovMultistake(uint64(l))
	return n
}

func (m *DAPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovMultistake(uint64(l))
	}
	if m.AgentId != 0 {
		n += 1 + sovMultistake(uint64(m.AgentId))
	}
	return n
}

func (m *DAPairs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovMultistake(uint64(l))
		}
	}
	return n
}

func sovMultistake(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMultistake(x uint64) (n int) {
	return sovMultistake(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MultiStakingDenomWhiteList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingDenomWhiteList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingDenomWhiteList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomList = append(m.DenomList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquivalentMultiplierRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquivalentMultiplierRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquivalentMultiplierRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Multiplier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquivalentStakedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EquivalentStakedAmount == nil {
				m.EquivalentStakedAmount = &types.Coin{}
			}
			if err := m.EquivalentStakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingAgent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingAgent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingAgent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakeDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegateAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegateAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingUnbonding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingUnbonding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingUnbonding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentId", wireType)
			}
			m.AgentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, MultiStakingUnbondingEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStakingUnbondingEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStakingUnbondingEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStakingUnbondingEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CompletionTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DAPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DAPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DAPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentId", wireType)
			}
			m.AgentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DAPairs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DAPairs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DAPairs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMultistake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMultistake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, DAPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMultistake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMultistake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMultistake(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMultistake
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMultistake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMultistake
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMultistake
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMultistake
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMultistake        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMultistake          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMultistake = fmt.Errorf("proto: unexpected end of group")
)
